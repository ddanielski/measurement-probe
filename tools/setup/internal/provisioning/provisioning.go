// Package provisioning handles WiFi provisioning secret generation.
package provisioning

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// Config holds WiFi provisioning settings.
type Config struct {
	PoP        string // Proof of Possession secret
	DeviceName string // Device name prefix
	TimeoutSec int    // Provisioning timeout
}

// Defaults holds default values for provisioning configuration.
type Defaults struct {
	DeviceName   string // Default device name prefix
	TimeoutSec   int    // Default provisioning timeout
	PopBytes     int    // Number of random bytes for PoP (hex encoded = 2x chars)
	OutputFile   string // Output filename (relative to generated dir)
	GeneratedDir string // Directory for generated files
}

// Setup handles provisioning configuration.
type Setup struct {
	defaults Defaults
}

// NewSetup creates a provisioning setup handler with the given defaults.
func NewSetup(defaults Defaults) *Setup {
	return &Setup{defaults: defaults}
}

// Generate creates or retrieves the provisioning configuration.
// Returns the config and whether it was newly generated.
func (s *Setup) Generate() (*Config, bool, error) {
	configPath := s.configPath()

	// Check for existing config
	if config, err := s.loadExisting(configPath); err == nil {
		return config, false, nil
	}

	// Generate new config
	config, err := s.generateNew()
	if err != nil {
		return nil, false, err
	}

	// Save to file
	if err := s.save(configPath, config); err != nil {
		return nil, false, err
	}

	return config, true, nil
}

func (s *Setup) configPath() string {
	return filepath.Join(s.defaults.GeneratedDir, s.defaults.OutputFile)
}

func (s *Setup) loadExisting(path string) (*Config, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	// Extract PoP from existing file
	for _, line := range strings.Split(string(content), "\n") {
		if strings.Contains(line, "PROVISIONING_POP") && strings.Contains(line, "\"") {
			start := strings.Index(line, "\"") + 1
			end := strings.LastIndex(line, "\"")
			if start > 0 && end > start {
				return &Config{
					PoP:        line[start:end],
					DeviceName: s.defaults.DeviceName,
					TimeoutSec: s.defaults.TimeoutSec,
				}, nil
			}
		}
	}

	return nil, fmt.Errorf("could not parse existing config")
}

func (s *Setup) generateNew() (*Config, error) {
	randomBytes := make([]byte, s.defaults.PopBytes)
	if _, err := rand.Read(randomBytes); err != nil {
		return nil, fmt.Errorf("failed to generate random bytes: %w", err)
	}

	return &Config{
		PoP:        hex.EncodeToString(randomBytes),
		DeviceName: s.defaults.DeviceName,
		TimeoutSec: s.defaults.TimeoutSec,
	}, nil
}

func (s *Setup) save(path string, config *Config) error {
	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	header := fmt.Sprintf(`/**
 * @file provisioning_config.h
 * @brief Auto-generated provisioning configuration
 *
 * DO NOT COMMIT THIS FILE TO VERSION CONTROL!
 * This file contains your unique device provisioning secret.
 *
 * Generated by: go run tools/setup/cmd/setup/main.go
 */

#pragma once

// Proof of Possession for BLE WiFi provisioning
// Use this secret in the ESP BLE Provisioning app
#define PROVISIONING_POP "%s"

// Device name prefix (MAC suffix will be appended)
#define PROVISIONING_DEVICE_NAME "%s"

// Provisioning timeout in seconds (0 = no timeout)
#define PROVISIONING_TIMEOUT_SEC %d
`, config.PoP, config.DeviceName, config.TimeoutSec)

	return os.WriteFile(path, []byte(header), 0644)
}
