// Package bsec handles Bosch BSEC library configuration.
package bsec

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// Config holds BSEC library configuration options.
type Config struct {
	ESPChip     string // "esp32", "esp32s2", "esp32s3", "esp32c3"
	ChipVariant string // "bme680" or "bme688"
	Voltage     string // "18v" or "33v"
	Interval    string // "3s" (LP) or "300s" (ULP)
	History     string // "4d" or "28d"
	DeepSleep   bool
}

// Name returns the configuration identifier string.
func (c *Config) Name() string {
	return fmt.Sprintf("%s_iaq_%s_%s_%s", c.ChipVariant, c.Voltage, c.Interval, c.History)
}

// SampleRate returns the BSEC sample rate macro name.
func (c *Config) SampleRate() string {
	if c.Interval == "300s" {
		return "BSEC_SAMPLE_RATE_ULP"
	}
	return "BSEC_SAMPLE_RATE_LP"
}

// IntervalMs returns the sampling interval in milliseconds.
func (c *Config) IntervalMs() int {
	if c.Interval == "300s" {
		return 300000
	}
	return 3000
}

// Paths holds configurable paths for BSEC setup.
type Paths struct {
	SourceDir     string   // Path to BSEC source (e.g., Bosch-BSEC2-Library)
	TargetDir     string   // Path to target directory for copied files
	AppConfigPath string   // Path to app_config.hpp (optional)
	Headers       []string // Header files to copy from src/inc
	ConfigFile    string   // Config data filename (e.g., "bsec_iaq.txt")
	LibraryName   string   // Library filename (e.g., "libalgobsec.a")
}

// Setup handles BSEC library configuration.
type Setup struct {
	paths Paths
}

// NewSetup creates a BSEC setup handler with the given paths.
func NewSetup(paths Paths) *Setup {
	return &Setup{paths: paths}
}

// Apply configures the BSEC library with the given settings.
func (s *Setup) Apply(config *Config) error {
	configSrcPath := s.configSourcePath(config)
	if _, err := os.Stat(configSrcPath); os.IsNotExist(err) {
		return fmt.Errorf("configuration not found: %s", configSrcPath)
	}

	if err := s.createTargetDirs(); err != nil {
		return err
	}

	if err := s.copyHeaders(); err != nil {
		return err
	}

	if err := s.copyLibrary(config.ESPChip); err != nil {
		return err
	}

	if err := s.generateConfigHeader(configSrcPath, config); err != nil {
		return err
	}

	return s.updateAppConfig(config)
}

func (s *Setup) configSourcePath(config *Config) string {
	return filepath.Join(
		s.paths.SourceDir, "src", "config",
		config.ChipVariant, config.Name(),
	)
}

func (s *Setup) createTargetDirs() error {
	dirs := []string{
		filepath.Join(s.paths.TargetDir, "include"),
		filepath.Join(s.paths.TargetDir, "lib"),
	}
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}
	return nil
}

func (s *Setup) copyHeaders() error {
	srcDir := filepath.Join(s.paths.SourceDir, "src", "inc")
	dstDir := filepath.Join(s.paths.TargetDir, "include")

	for _, h := range s.paths.Headers {
		if err := copyFile(filepath.Join(srcDir, h), filepath.Join(dstDir, h)); err != nil {
			return fmt.Errorf("failed to copy header %s: %w", h, err)
		}
	}
	return nil
}

func (s *Setup) copyLibrary(espChip string) error {
	srcPath := filepath.Join(s.paths.SourceDir, "src", espChip, s.paths.LibraryName)
	if _, err := os.Stat(srcPath); os.IsNotExist(err) {
		return fmt.Errorf("BSEC library not found for %s: %s", espChip, srcPath)
	}

	dstPath := filepath.Join(s.paths.TargetDir, "lib", s.paths.LibraryName)
	return copyFile(srcPath, dstPath)
}

func (s *Setup) generateConfigHeader(configSrcPath string, config *Config) error {
	txtPath := filepath.Join(configSrcPath, s.paths.ConfigFile)
	content, err := os.ReadFile(txtPath)
	if err != nil {
		return fmt.Errorf("failed to read config file: %w", err)
	}

	header := s.formatConfigHeader(config, string(content))
	dstPath := filepath.Join(s.paths.TargetDir, "include", "bsec_config.h")

	return os.WriteFile(dstPath, []byte(header), 0644)
}

func (s *Setup) formatConfigHeader(config *Config, rawData string) string {
	return fmt.Sprintf(`/**
 * @file bsec_config.h
 * @brief BSEC configuration for %s IAQ
 * @target %s
 * @config %s
 * @generated by setup tool
 */

#pragma once

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

// %s IAQ config: %s supply, %s sample rate, %s history
static const uint8_t bsec_config_iaq[] = {
%s
};

static const uint32_t bsec_config_iaq_len = sizeof(bsec_config_iaq);

#ifdef __cplusplus
}
#endif

// Sample rate configuration (use in C++ code)
#define BSEC_CONFIGURED_SAMPLE_RATE %s
#define BSEC_CONFIGURED_INTERVAL_MS %d
`,
		strings.ToUpper(config.ChipVariant),
		config.ESPChip,
		config.Name(),
		strings.ToUpper(config.ChipVariant),
		config.Voltage, config.Interval, config.History,
		formatConfigData(rawData),
		config.SampleRate(),
		config.IntervalMs(),
	)
}

func (s *Setup) updateAppConfig(config *Config) error {
	if s.paths.AppConfigPath == "" {
		return nil // No app config to update
	}

	content, err := os.ReadFile(s.paths.AppConfigPath)
	if err != nil {
		return nil // Non-fatal: file might not exist yet
	}

	lines := strings.Split(string(content), "\n")
	found := false

	for i, line := range lines {
		if strings.Contains(line, "BSEC_DEEP_SLEEP_MODE") {
			lines[i] = fmt.Sprintf("inline constexpr bool BSEC_DEEP_SLEEP_MODE = %t;", config.DeepSleep)
			found = true
			break
		}
	}

	if !found {
		// Insert before closing namespace brace
		for i := len(lines) - 1; i >= 0; i-- {
			if strings.Contains(lines[i], "} // namespace") {
				insert := fmt.Sprintf("\n// BSEC operation mode (generated by setup tool)\ninline constexpr bool BSEC_DEEP_SLEEP_MODE = %t;\n", config.DeepSleep)
				lines[i] = insert + lines[i]
				break
			}
		}
	}

	return os.WriteFile(s.paths.AppConfigPath, []byte(strings.Join(lines, "\n")), 0644)
}

func formatConfigData(data string) string {
	data = strings.TrimSpace(data)
	values := strings.Split(data, ",")

	var lines []string
	var line []string

	for i, v := range values {
		line = append(line, strings.TrimSpace(v))
		if len(line) >= 16 || i == len(values)-1 {
			lines = append(lines, "    "+strings.Join(line, ", "))
			line = nil
		}
	}

	return strings.Join(lines, ",\n")
}

func copyFile(src, dst string) error {
	content, err := os.ReadFile(src)
	if err != nil {
		return err
	}
	return os.WriteFile(dst, content, 0644)
}
